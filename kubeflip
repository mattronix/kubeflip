#!/usr/bin/env bash

# kubeflip - A utility to manage and switch between Kubernetes context files
# Usage: kubeflip activate "name"

set -e

# Configuration
KUBEFLIP_DIR="$HOME/.kubeflip"
CONTEXTS_DIR="$KUBEFLIP_DIR/contexts"
KUBE_CONFIG="$HOME/.kube/config"
CURRENT_LINK="$KUBEFLIP_DIR/current"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Ensure kubeflip directory structure exists
init_kubeflip() {
    mkdir -p "$CONTEXTS_DIR"
    
    # If this is the first run and there's already a kube config, back it up
    if [[ -f "$KUBE_CONFIG" && ! -f "$CONTEXTS_DIR/default" ]]; then
        echo -e "${YELLOW}Backing up existing kubectl config as 'default'${NC}"
        cp "$KUBE_CONFIG" "$CONTEXTS_DIR/default"
    fi
}

# Display usage information
show_help() {
    cat << EOF
kubeflip - Kubernetes context file manager

USAGE:
    kubeflip <command> [arguments]

COMMANDS:
    activate <name>     Switch to the specified context configuration
    store <name>        Store the current kubectl config with the given name
    new <name>          Create a new empty context configuration
    list               List all stored context configurations
    current            Show the currently active context configuration
    remove <name>      Remove a stored context configuration
    help               Show this help message

EXAMPLES:
    kubeflip activate production
    kubeflip store development
    kubeflip new staging
    kubeflip list
    kubeflip current
    kubeflip remove old-cluster

CONFIGURATION:
    Context files are stored in: $CONTEXTS_DIR
    Current kubectl config: $KUBE_CONFIG

EOF
}

# List all available contexts
list_contexts() {
    echo -e "${BLUE}Available contexts:${NC}"
    
    if [[ ! -d "$CONTEXTS_DIR" || -z "$(ls -A "$CONTEXTS_DIR" 2>/dev/null)" ]]; then
        echo -e "${YELLOW}No contexts found. Use 'kubeflip store <name>' to store your first context.${NC}"
        return
    fi
    
    local current_context=""
    if [[ -L "$CURRENT_LINK" ]]; then
        current_context=$(basename "$(readlink "$CURRENT_LINK")")
    fi
    
    for context_file in "$CONTEXTS_DIR"/*; do
        if [[ -f "$context_file" ]]; then
            local context_name=$(basename "$context_file")
            if [[ "$context_name" == "$current_context" ]]; then
                echo -e "  ${GREEN}* $context_name${NC} (active)"
            else
                echo -e "    $context_name"
            fi
        fi
    done
}

# Show current active context
show_current() {
    if [[ -L "$CURRENT_LINK" ]]; then
        local current_context=$(basename "$(readlink "$CURRENT_LINK")")
        echo -e "${GREEN}Current active context: $current_context${NC}"
        
        # Also show the current kubectl context for reference
        if command -v kubectl &> /dev/null && [[ -f "$KUBE_CONFIG" ]]; then
            local kubectl_context=$(kubectl config current-context 2>/dev/null || echo "none")
            echo -e "${BLUE}Current kubectl context: $kubectl_context${NC}"
        fi
    else
        echo -e "${YELLOW}No active context set${NC}"
    fi
}

# Store current kubectl config with a name
store_context() {
    local name="$1"
    
    if [[ -z "$name" ]]; then
        echo -e "${RED}Error: Context name is required${NC}"
        echo "Usage: kubeflip store <name>"
        exit 1
    fi
    
    if [[ ! -f "$KUBE_CONFIG" ]]; then
        echo -e "${RED}Error: No kubectl config found at $KUBE_CONFIG${NC}"
        exit 1
    fi
    
    local context_path="$CONTEXTS_DIR/$name"
    
    if [[ -f "$context_path" ]]; then
        echo -e "${YELLOW}Context '$name' already exists. Overwrite? (y/N)${NC}"
        read -r response
        if [[ ! "$response" =~ ^[yY]$ ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi
    
    cp "$KUBE_CONFIG" "$context_path"
    echo -e "${GREEN}Context '$name' stored successfully${NC}"
}

# Create a new empty context configuration
new_context() {
    local name="$1"
    
    if [[ -z "$name" ]]; then
        echo -e "${RED}Error: Context name is required${NC}"
        echo "Usage: kubeflip new <name>"
        exit 1
    fi
    
    local context_path="$CONTEXTS_DIR/$name"
    
    if [[ -f "$context_path" ]]; then
        echo -e "${YELLOW}Context '$name' already exists. Overwrite? (y/N)${NC}"
        read -r response
        if [[ ! "$response" =~ ^[yY]$ ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi
    
    # Create a minimal kubectl config template
    cat > "$context_path" << EOF
apiVersion: v1
kind: Config
clusters: []
contexts: []
current-context: ""
preferences: {}
users: []
EOF
    
    echo -e "${GREEN}New empty context '$name' created successfully${NC}"
    echo -e "${BLUE}You can now configure this context using kubectl commands and then activate it with:${NC}"
    echo -e "  kubeflip activate $name"
}

# Activate a stored context
activate_context() {
    local name="$1"
    
    if [[ -z "$name" ]]; then
        echo -e "${RED}Error: Context name is required${NC}"
        echo "Usage: kubeflip activate <name>"
        exit 1
    fi
    
    local context_path="$CONTEXTS_DIR/$name"
    
    if [[ ! -f "$context_path" ]]; then
        echo -e "${RED}Error: Context '$name' not found${NC}"
        echo "Available contexts:"
        list_contexts
        exit 1
    fi
    

    
    # Create .kube directory if it doesn't exist
    mkdir -p "$(dirname "$KUBE_CONFIG")"
    
    # Remove existing config (file or symlink) and create new symlink
    rm -f "$KUBE_CONFIG"
    ln -s "$context_path" "$KUBE_CONFIG"
    
    # Update current context tracking
    ln -sf "$context_path" "$CURRENT_LINK"
    
    echo -e "${GREEN}Activated context: $name${NC}"
    
    # Show current kubectl context for confirmation
    if command -v kubectl &> /dev/null; then
        local kubectl_context=$(kubectl config current-context 2>/dev/null || echo "none")
        echo -e "${BLUE}Current kubectl context: $kubectl_context${NC}"
    fi
}

# Remove a stored context
remove_context() {
    local name="$1"
    
    if [[ -z "$name" ]]; then
        echo -e "${RED}Error: Context name is required${NC}"
        echo "Usage: kubeflip remove <name>"
        exit 1
    fi
    
    local context_path="$CONTEXTS_DIR/$name"
    
    if [[ ! -f "$context_path" ]]; then
        echo -e "${RED}Error: Context '$name' not found${NC}"
        exit 1
    fi
    
    echo -e "${YELLOW}Are you sure you want to remove context '$name'? (y/N)${NC}"
    read -r response
    if [[ "$response" =~ ^[yY]$ ]]; then
        rm "$context_path"
        
        # If this was the current context, remove the current link
        if [[ -L "$CURRENT_LINK" && "$(readlink "$CURRENT_LINK")" == "$context_path" ]]; then
            rm "$CURRENT_LINK"
        fi
        
        echo -e "${GREEN}Context '$name' removed successfully${NC}"
    else
        echo "Cancelled."
    fi
}

# Main command dispatcher
main() {
    init_kubeflip
    
    case "${1:-help}" in
        activate)
            activate_context "$2"
            ;;
        store)
            store_context "$2"
            ;;
        new)
            new_context "$2"
            ;;
        list|ls)
            list_contexts
            ;;
        current)
            show_current
            ;;
        remove|rm)
            remove_context "$2"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo -e "${RED}Unknown command: $1${NC}"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"